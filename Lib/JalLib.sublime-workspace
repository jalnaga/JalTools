{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"reutnrA",
				"returnArray"
			],
			[
				"sid",
				"sideIndex"
			],
			[
				"targe",
				"targetIndex"
			],
			[
				"get_front",
				"get_frontBack\t(name.ms)"
			],
			[
				"get_sid",
				"get_side_part_index"
			],
			[
				"refin",
				"refine_nameArray\t(name.ms)"
			],
			[
				"targA",
				"targetArray"
			],
			[
				"get_base",
				"get_base_type_part_char"
			],
			[
				"targpoi",
				"targetPosInNameArray"
			],
			[
				"is_front",
				"is_front_back_char"
			],
			[
				"frontB",
				"frontBackIndex"
			],
			[
				"__N",
				"__nubStr"
			],
			[
				"splienpr",
				"split_nameParts_to_refined_nameArray"
			],
			[
				"realN",
				"realNameIndex"
			],
			[
				"__",
				"__nubStr"
			],
			[
				"get_type",
				"get_type_part_index"
			],
			[
				"get_fron",
				"get_front_back_part_index"
			],
			[
				"__nam",
				"__nameParts"
			],
			[
				"get_index",
				"get_index_part_index"
			],
			[
				"__na",
				"__nameParts"
			],
			[
				"__Nam",
				"__namePartsOrder"
			],
			[
				"tempAr",
				"tempAfterRealNameArray"
			],
			[
				"get_real",
				"get_realName_part_index"
			],
			[
				"match",
				"match_nameArray_with_parts_order\t(name.ms)"
			],
			[
				"is_fron",
				"is_front_back_char"
			],
			[
				"__name",
				"__namePartsOrder"
			],
			[
				"installI",
				"installIniFile"
			],
			[
				"exterded",
				"externalDestDirTxt"
			],
			[
				"Inst",
				"Install"
			],
			[
				"scrip",
				"scriptStr"
			],
			[
				"callb",
				"callbacks.addScript"
			],
			[
				"scriptF",
				"scriptFileName"
			],
			[
				"getFilena",
				"getFilenameFile"
			],
			[
				"listviewp",
				"ListViewOps.AddLvItem"
			],
			[
				"listvie",
				"ListViewOps.initListView"
			],
			[
				"clumping",
				"clumpingGroupColor"
			],
			[
				"meshopsetvertco",
				"meshop.setVertColor"
			],
			[
				"snapshot",
				"snapshotAsMesh"
			],
			[
				"polyopgetnum",
				"polyop.getNumVerts"
			],
			[
				"getface",
				"getface"
			],
			[
				"setvert",
				"setVertColor"
			],
			[
				"hairPlane",
				"hairPlanes"
			],
			[
				"getVertCo",
				"getvertcolor"
			],
			[
				"verte",
				"VertexPaint"
			],
			[
				"hairplane",
				"hairPlanes"
			],
			[
				"vertexp",
				"VertexPaintTool"
			],
			[
				"leftRightcob",
				"leftRightColObj"
			],
			[
				"update_progr",
				"update_progress"
			],
			[
				"stri",
				"String"
			],
			[
				"inputCurrentS",
				"inputCurrentStepText"
			],
			[
				"Edit",
				"Editable_Poly"
			],
			[
				"isVal",
				"isValidNode"
			],
			[
				"hairPlan",
				"hairPlane"
			],
			[
				"hairBon",
				"hairBones"
			],
			[
				"boneGroud",
				"boneGroupDdlItems"
			],
			[
				"boneGroupD",
				"boneGroupDdlItems"
			],
			[
				"standardm",
				"Standardmaterial"
			],
			[
				"hairBone",
				"hairBonesArray"
			],
			[
				"weightGroup",
				"weightGroupNum"
			],
			[
				"opzweighro",
				"optimizedWeightGroup"
			],
			[
				"isWeightedb",
				"isWeightedByBottomBone"
			],
			[
				"isweighteby",
				"isWeightedByUpBone"
			],
			[
				"dummyPos",
				"dummyPosArray"
			],
			[
				"compareHair",
				"compareHairPlanePos"
			],
			[
				"baseHairPl",
				"baseHairPlanePos"
			],
			[
				"setVertColor",
				"meshop.setVertColor"
			],
			[
				"weightGrou",
				"weightGroupNum"
			],
			[
				"weightGr",
				"weightGroupArray"
			],
			[
				"gen_ave",
				"gen_average_pos_from_verts_index"
			],
			[
				"meshopgetver",
				"meshop.getVert"
			],
			[
				"convert",
				"convertToPoly"
			],
			[
				"getFilen",
				"getFilenamePath"
			],
			[
				"setWeightGroup",
				"setWeightGroupNum"
			],
			[
				"init",
				"initWindow\tfunction"
			],
			[
				"class",
				"classOf"
			],
			[
				"def",
				"defs\tMethod"
			],
			[
				"if",
				"ifmain\tif __name__ == '__main__'"
			],
			[
				"de",
				"defs\tMethod"
			],
			[
				"font",
				"font-family"
			],
			[
				"Edita",
				"Editable_mesh"
			],
			[
				"filetyp",
				"getFilenameType"
			],
			[
				"optimized",
				"optimizedTotalSplineNumOfDuplicatedSp"
			],
			[
				"del",
				"delete"
			],
			[
				"detach",
				"detachNum"
			],
			[
				"to",
				"totalSplineNum"
			],
			[
				"ax",
				"axisY"
			],
			[
				"rotat",
				"rotationpart"
			],
			[
				"axi",
				"axisY"
			],
			[
				"comparemp",
				"compareMapVertIndex"
			],
			[
				"resul",
				"resultArray"
			],
			[
				"sameumpv",
				"sameUMapVertsData"
			],
			[
				"inputmapv",
				"inputMapVertPos2"
			],
			[
				"inputMap",
				"inputMapVertPos1"
			],
			[
				"high",
				"higherVMapVerts"
			],
			[
				"same",
				"sameUMapVertsIndexes"
			],
			[
				"inputob",
				"inputObjUVPos"
			],
			[
				"inputo",
				"inputObjUPos"
			],
			[
				"inputOb",
				"inputObjUVPos"
			],
			[
				"getnum",
				"getNumMapVerts"
			],
			[
				"numMap",
				"numMapVerts"
			],
			[
				"wra",
				"wrapObj"
			],
			[
				"fla",
				"flatObj"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/_compileTarget.ms",
			"settings":
			{
				"buffer_size": 763,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "struct _Name (\n    /*************************************************/\n    /* Default name structure:\n    /*    [Base] [Type] [Side] [RealName] [Index]\n    /*    ex) Bip001 Dummy L SpineA 001\n    /*************************************************/\n    __namePartsOrder = #(#npBase, #npType, #npSide, #npFrontBack, #npRealName, #npIndex),\n    __nameParts = #(\"Base\", \"Type\", \"Side\", \"FrontBack\", \"RealName\", \"Index\"),\n    __nubStr = \"Nub\",\n    __sideStrArray = #(\"L\", \"R\"),\n    __frontBackStrArray = #(\"F\", \"B\"),\n\n    fn set_nubStr inStr = (\n        __nubStr = inStr\n    ),\n\n    fn set_leftStr inStr = (\n        __sideStrArray[1] = inStr\n    ),\n\n    fn set_rightStr inStr = (\n        __sideStrArray[2] = inStr\n    ),\n\n    fn set_frontStr inStr = (\n        __frontBackStrArray[1] = inStr\n    ),\n\n    fn set_backStr inStr = (\n        __frontBackStrArray[2] = inStr\n    ),\n\n    fn get_leftStr = (\n        __sideStrArray[1]\n    ),\n\n    fn get_rightStr = (\n        __sideStrArray[2]\n    ),\n\n    fn get_frontStr = (\n        __frontBackStrArray[1]\n    ),\n\n    fn get_backStr = (\n        __frontBackStrArray[2]\n    ),\n\n    fn get_base_part_index = (\n        local returnVal = findItem __namePartsOrder #npBase\n\n        returnVal\n    ),\n\n    fn get_type_part_index = (\n        local returnVal = findItem __namePartsOrder #npType\n\n        returnVal\n    ),\n\n    fn get_side_part_index = (\n        local returnVal = findItem __namePartsOrder #npSide\n\n        returnVal\n    ),\n\n    fn get_front_back_part_index = (\n        local returnVal = findItem __namePartsOrder #npFrontBack\n\n        returnVal\n    ),\n\n    fn get_realName_part_index = (\n        local returnVal = findItem __namePartsOrder #npRealName\n\n        returnVal\n    ),\n\n    fn get_index_part_index = (\n        local returnVal = findItem __namePartsOrder #npIndex\n\n        returnVal\n    ),\n\n    fn set_name_parts_order inOrder = (\n        __nameParts = inOrder\n        __namePartsOrder[(findItem __nameParts \"Base\")] = #npBase\n        __namePartsOrder[(findItem __nameParts \"Type\")] = #npType\n        __namePartsOrder[(findItem __nameParts \"Side\")] = #npSide\n        __namePartsOrder[(findItem __nameParts \"FrontBack\")] = #npFrontBack\n        __namePartsOrder[(findItem __nameParts \"RealName\")] = #npRealName\n        __namePartsOrder[(findItem __nameParts \"Index\")] = #npIndex\n    ),\n\n    fn split_nameParts_to_refined_nameArray = (\n        local realNameIndex = get_realName_part_index()\n        local beforeRealNameArray = for i = 1 to (realNameIndex - 1) collect __namePartsOrder[i]\n        local afterRealNameArray = for i = (realNameIndex + 1) to __namePartsOrder.count collect __namePartsOrder[i]\n        local returnArray = #(beforeRealNameArray, #(#npRealName), afterRealNameArray)\n\n        returnArray\n    ),\n\n    fn split_into_string_and_digit inStr = (\n        t = trimRight inStr \"0123456789\"\n        #(t, substring inStr (t.count+1) -1)\n    ),\n\n    fn is_upper_case inChar = (\n        if inChar == toLower inChar then return false else return true\n    ),\n\n    fn is_lower_case inChar = (\n        if inChar == toLower inChar then return true else return false\n    ),\n\n    fn get_filteringChar inStr = (\n        if (matchPattern inStr pattern:\"* *\") then return \" \"\n        if (matchPattern inStr pattern:\"*_*\") then return \"_\"\n        return \"\"\n    ),\n\n    fn filter_by_filteringChar inStr = (\n        local filChar = get_filteringChar inStr\n        local returnArray = #()\n        local splittedPart = \"\"\n        splittedPart += inStr[1]\n        for i = 2 to inStr.count do (\n            if (inStr[i] == filChar) then (\n                append returnArray splittedPart\n                i = i + 1\n                splittedPart = \"\"\n            )\n            else splittedPart += inStr[i]\n        )\n        if splittedPart != \"\" then append returnArray splittedPart\n\n        returnArray\n    ),\n\n    fn filter_by_upper_case inStr = (\n        local returnArray = #()\n        local splittedPart = \"\"\n        splittedPart += inStr[1]\n        for i = 2 to inStr.count do (\n            if (is_upper_case inStr[i]) then (\n                append returnArray splittedPart\n                splittedPart = inStr[i]\n            )\n            else splittedPart += inStr[i]\n        )\n        if splittedPart != \"\" then append returnArray splittedPart\n\n        returnArray\n    ),\n\n    fn has_digit inStr = (\n        local digitStr = (split_into_string_and_digit inStr)[2]\n        if digitStr != \"\" then return true\n        else return false\n    ),\n\n    fn is_digit inStr = (\n        local returnVal = false\n        if (has_digit inStr) then (\n            local splittedStrArray = split_into_string_and_digit inStr\n            if splittedStrArray[1] ==\"\" and splittedStrArray[2] != \"\" then returnVal = true\n            else returnVal = false\n        )\n\n        returnVal\n    ),\n\n    fn is_side_char inChar = (\n        local returnVal = false\n        if (findItem __sideStrArray inChar) != 0 then returnVal = true\n        returnVal\n    ),\n\n    fn is_frontBack_char inChar = (\n        local returnVal = false\n        if (findItem __frontBackStrArray inChar) != 0 then returnVal = true\n        returnVal\n    ),\n\n    fn filter_name inStr = (\n        local nameArray = #()\n        local filChar = get_filteringChar inStr\n        if filChar == \"\" then (\n            nameArray = filter_by_upper_case inStr\n            local tempArray = #()\n            for item in nameArray do (\n                if (has_digit item) then (\n                    local splittedStrArray = split_into_string_and_digit item\n                    append tempArray splittedStrArray[1]\n                    append tempArray splittedStrArray[2]\n                )\n                else append tempArray item\n            )\n            nameArray = deepCopy tempArray\n        )\n        else nameArray = filter_by_filteringChar inStr\n\n        nameArray\n    ),\n\n    fn refine_nameArray_empty inNameArray = (\n        local nameArray = #()\n        for item in inNameArray do (\n            if item != \"\" then append nameArray item\n        )\n\n        return nameArray\n    ),\n\n    fn refine_nameArray_longer_than_nameParts inNameArray = (\n        local nameArray = deepCopy inNameArray\n        local beforeRealNameArray = #()\n        local tempAfterRealNameArray = #()\n        local afterRealNameArray = #()\n        local returnArray = #()\n\n        for i = 1 to (get_realName_part_index() - 1) do (\n            local k = 1\n            while nameArray.count > 0 do (\n                case __namePartsOrder[i] of (\n                    #npBase:(\n                        if nameArray[k] != \"\" then (\n                            append beforeRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k += 1\n                            exit\n                        )\n                    )\n                    #npType:(\n                        if nameArray[k] != \"\" then (\n                            append beforeRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k += 1\n                            exit\n                        )\n                    )\n                    #npSide:(\n                        if (is_side_char nameArray[k]) then (\n                            append beforeRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k += 1\n                            exit\n                        )\n                    )\n                    #npFrontBack:(\n                        if (is_frontBack_char nameArray[k]) then (\n                            append beforeRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k += 1\n                            exit\n                        )\n                    )\n                    #npIndex:(\n                        if (is_digit nameArray[k]) or (nameArray[k] == __nubStr) then (\n                            append beforeRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k += 1\n                            exit\n                        )\n                    )\n                    default: (\n                        k += 1\n                        exit\n                    )\n                )\n            )\n        )\n\n        for i = __namePartsOrder.count to (get_realName_part_index() + 1) by -1 do (\n            local k = nameArray.count\n            while nameArray.count > 1 do (\n                case __namePartsOrder[i] of (\n                    #npBase:(\n                        if nameArray[k] != \"\" then (\n                            append tempAfterRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k -= 1\n                            exit\n                        )\n                    )\n                    #npType:(\n                        if nameArray[k] != \"\" then (\n                            append tempAfterRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k -= 1\n                            exit\n                        )\n                    )\n                    #npSide:(\n                        if (is_side_char nameArray[k]) then (\n                            append tempAfterRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k -= 1\n                            exit\n                        )\n                    )\n                    #npFrontBack:(\n                        if (is_frontBack_char nameArray[k]) then (\n                            append tempAfterRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k -= 1\n                            exit\n                        )\n                    )\n                    #npIndex:(\n                        if (is_digit nameArray[k]) or (nameArray[k] == __nubStr) then (\n                            append tempAfterRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k -= 1\n                            exit\n                        )\n                    )\n                    default: (\n                        k -= 1\n                        exit\n                    )\n                )\n            )\n        )\n        afterRealNameArray = for i = tempAfterRealNameArray.count to 1 by -1 collect tempAfterRealNameArray[i]\n\n        returnArray = #(beforeRealNameArray, nameArray, afterRealNameArray)\n        returnArray\n    ),\n\n    fn refine_nameArray_shorter_than_nameParts inNameArray = (\n        local nameArray = deepCopy inNameArray\n        local beforeRealNameArray = #()\n        local tempAfterRealNameArray = #()\n        local afterRealNameArray = #()\n        local returnArray = #()\n\n        for i = __namePartsOrder.count to (get_realName_part_index()) by -1 do (\n            local k = nameArray.count\n            while nameArray.count > 0 do (\n                case __namePartsOrder[i] of (\n                    #npBase:(\n                        if nameArray[k] != \"\" then (\n                            append tempAfterRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k -= 1\n                            exit\n                        )\n                    )\n                    #npType:(\n                        if nameArray[k] != \"\" then (\n                            append tempAfterRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k -= 1\n                            exit\n                        )\n                    )\n                    #npSide:(\n                        if (is_side_char nameArray[k]) then (\n                            append tempAfterRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k -= 1\n                            exit\n                        )\n                    )\n                    #npFrontBack:(\n                        if (is_frontBack_char nameArray[k]) then (\n                            append tempAfterRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k -= 1\n                            exit\n                        )\n                    )\n                    #npIndex:(\n                        if (is_digit nameArray[k]) or (nameArray[k] == __nubStr) then (\n                            append tempAfterRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k -= 1\n                            exit\n                        )\n                    )\n                    default: (\n                        k -= 1\n                        exit\n                    )\n                )\n            )\n        )\n        afterRealNameArray = for i = tempAfterRealNameArray.count to 1 by -1 collect tempAfterRealNameArray[i]\n\n        for i = 1 to (get_realName_part_index() - 1) do (\n            local k = 1\n            while nameArray.count > 1 do (\n                case __namePartsOrder[i] of (\n                    #npBase:(\n                        if nameArray[k] != \"\" then (\n                            append beforeRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k += 1\n                            exit\n                        )\n                    )\n                    #npType:(\n                        if nameArray[k] != \"\" then (\n                            append beforeRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k += 1\n                            exit\n                        )\n                    )\n                    #npSide:(\n                        if (is_side_char nameArray[k]) then (\n                            append beforeRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k += 1\n                            exit\n                        )\n                    )\n                    #npFrontBack:(\n                        if (is_frontBack_char nameArray[k]) then (\n                            append beforeRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k += 1\n                            exit\n                        )\n                    )\n                    #npIndex:(\n                        if (is_digit nameArray[k]) or (nameArray[k] == __nubStr) then (\n                            append beforeRealNameArray nameArray[k]\n                            nameArray = deleteItem nameArray k\n                            exit\n                        )\n                        else (\n                            k += 1\n                            exit\n                        )\n                    )\n                    default: (\n                        k += 1\n                        exit\n                    )\n                )\n            )\n        )\n\n        returnArray = #(beforeRealNameArray, nameArray, afterRealNameArray)\n        returnArray\n    ),\n\n    fn refine_nameArray inNameArray = (\n        local returnArray = #(#(), #(), #())\n        if (get_realName_part_index()) > 1 then (\n            if inNameArray.count < __nameParts.count then returnArray = refine_nameArray_shorter_than_nameParts inNameArray\n            else returnArray = refine_nameArray_longer_than_nameParts inNameArray\n        )\n        else returnArray = #(#(), inNameArray, #())\n        returnArray\n    ),\n\n    fn split_into_refined_nameArray inStr = (\n        local splittedNameArray = filter_name inStr\n        local nameArray = refine_nameArray splittedNameArray\n        nameArray\n    ),\n\n    fn combine_nameArray inNameArray inFilChar = (\n        local returnStr = \"\"\n        local copiedNameArray = deepCopy inNameArray\n        local refinedNameArray = refine_nameArray_empty copiedNameArray\n        if refinedNameArray.count > 1 then (\n            for i = 1 to refinedNameArray.count - 1 do (\n                returnStr += refinedNameArray[i]\n                returnStr += inFilChar\n            )\n\n            returnStr += refinedNameArray[refinedNameArray.count]\n        )\n        else returnStr = refinedNameArray[1]\n\n        returnStr\n    ),\n\n    fn get_realName inStr = (\n        local filChar = get_filteringChar inStr\n        local nameArray = split_into_refined_nameArray inStr\n        local realNameArray = nameArray[2]\n        local returnStr = \"\"\n        returnStr = combine_nameArray realNameArray filChar\n\n        returnStr\n    ),\n\n    fn get_pos_from_refined_nameArray inType = (\n        local returnVal = 2\n        case inType of (\n            #npBase:(\n                if (get_base_part_index()) < (get_realName_part_index()) then returnVal = 1\n                else returnVal = 3\n            )\n            #npType:(\n                if (get_type_part_index()) < (get_realName_part_index()) then returnVal = 1\n                else returnVal = 3\n            )\n            #npSide:(\n                if (get_side_part_index()) < (get_realName_part_index()) then returnVal = 1\n                else returnVal = 3\n            )\n            #npFrontBack:(\n                if (get_front_back_part_index()) < (get_realName_part_index()) then returnVal = 1\n                else returnVal = 3\n            )\n            #npIndex:(\n                if (get_index_part_index()) < (get_realName_part_index()) then returnVal = 1\n                else returnVal = 3\n            )\n            default: returnVal = 2\n        )\n\n        returnVal\n    ),\n\n    fn get_index_side_frontBack_part_char inNameArray inNamePartsOrder inType = (\n        local returnStr = \"\"\n        local nameArray = deepCopy inNameArray\n        local baseIndex = findItem inNamePartsOrder #npBase\n        local typeIndex = findItem inNamePartsOrder #npType\n        local indexIndex = findItem inNamePartsOrder #npIndex\n        local sideIndex = findItem inNamePartsOrder #npSide\n        local frontBackIndex = findItem inNamePartsOrder #npFrontBack\n        local targetIndex = 0\n        case inType of (\n            #npIndex: targetIndex = indexIndex\n            #npSide: targetIndex = sideIndex\n            #npFrontBack: targetIndex = frontBackIndex\n        )\n        format \"nameArray:%  targetIndex:% inNamePartsOrder:%\\n\" nameArray targetIndex inNamePartsOrder\n\n        if targetIndex != 0 then (\n            local targetArray = #()\n            case inType of (\n                #npIndex: targetArray = for i = 1 to nameArray.count where ((is_digit nameArray[i]) or (nameArray[i] == __nubStr)) collect nameArray[i]\n                #npSide: targetArray = for i = 1 to nameArray.count where (is_side_char nameArray[i]) collect nameArray[i]\n                #npFrontBack: targetArray = targetArray = for i = 1 to nameArray.count where (is_frontBack_char nameArray[i]) collect nameArray[i]\n            )\n            format \"targetArray:%\\n\" targetArray\n            if targetArray.count > 0 then (\n                if targetIndex < (baseIndex + typeIndex) then (\n                    if baseIndex != 0 and typeIndex != 0 then (\n                        if targetArray.count == 1 then (\n                            returnStr = targetArray[1]\n                        )\n                        if targetArray.count == 2 then (\n                            local firstPartIndex = amin #(baseIndex, typeIndex)\n                            if (abs (targetIndex - firstPartIndex)) == 1 then returnStr = targetArray[1]\n                            else returnStr = targetArray[2]\n                        )\n                        if targetArray.count == 3 then (\n                            returnStr = targetArray[2]\n                        )\n                    )\n                    else returnStr = targetArray[1]\n                )\n                if targetIndex >= (baseIndex + typeIndex) then (\n                    if targetArray.count == 1 then (\n                        local targetPosInNameArray = findItem nameArray targetArray[1]\n                        local baseGap = abs (baseIndex - targetPosInNameArray)\n                        if baseIndex == 0 then baseGap = 999\n                        local typeGap = abs (typeIndex - targetPosInNameArray)\n                        if typeIndex == 0 then typeGap = 999\n                        local targetGap = abs (targetIndex - targetPosInNameArray)\n                        format \"baseGap:% typeGap:% targetGap:%\\n\" baseGap typeGap targetGap\n                        if targetGap < baseGap or targetGap < typeGap then returnStr = targetArray[1]\n                        else returnStr = \"\"\n                    )\n                    if targetArray.count > 1 then returnStr = targetArray[targetArray.count]\n                )\n            )\n        )\n\n        returnStr\n    ),\n\n    fn get_base_type_part_char inNameArray inNamePartsArray inType = (\n        local returnStr = \"\"\n        local baseIndex = findItem inNamePartsArray #npBase\n        local typeIndex = findItem inNamePartsArray #npType\n        local indexIndex = findItem inNameArray #npIndex\n        local sideIndex = findItem inNameArray #npSide\n        local frontBackIndex = findItem inNameArray #npFrontBack\n        local tempNameArray = deepCopy inNameArray\n\n        if (findItem inNamePartsArray inType) != 0 then (\n            for i = 1 to inNamePartsArray.count do (\n                local tempResult = get_index_side_frontBack_part_char inNameArray inNamePartsArray inNamePartsArray[i]\n                if tempResult != \"\" then tempNameArray = deleteItem tempNameArray (findItem tempNameArray tempResult)\n            )\n            format \"tempNameArray:%\\n\" tempNameArray\n            if tempNameArray.count > 0 then (\n                if inType == #npBase then (\n                    if tempNameArray.count == 2 then (\n                        if baseIndex < typeIndex then returnStr = tempNameArray[1]\n                        else returnStr = tempNameArray[2]\n                    )\n\n                    if tempNameArray.count == 1 then (\n                        if typeIndex == 0 or baseIndex == 1 then returnStr = tempNameArray[1]\n                        else (\n                            if baseIndex < typeIndex then returnStr = tempNameArray[1]\n                            else (\n                                if baseIndex < (indexIndex + sideIndex + frontBackIndex) then returnStr = tempNameArray[1]\n                                else returnStr = \"\"\n                            )\n                        )\n                    )\n                )\n                if inType == #npType then (\n                    if tempNameArray.count == 2 then (\n                        if typeIndex < baseIndex then returnStr = tempNameArray[1]\n                        else returnStr = tempNameArray[2]\n                    )\n\n                    if tempNameArray.count == 1 then (\n                        if baseIndex == 0 or typeIndex == 1 then returnStr = tempNameArray[1]\n                        else (\n                            if typeIndex < baseIndex then returnStr = \"\"\n                            if typeIndex < (indexIndex + sideIndex + frontBackIndex) then returnStr = \"\"\n                            else returnStr = tempNameArray[1]\n                        )\n                    )\n                )\n            )\n        )\n\n        returnStr\n    ),\n\n    fn match_refined_nameArray_with_namePartsOrder inStr = (\n        local namePartsOrder = split_nameParts_to_refined_nameArray()\n        local nameArray = split_into_refined_nameArray inStr\n        local beforeRealNameArray = nameArray[1]\n        local afterRealNameArray = nameArray[3]\n        local returnArray = #(#(), nameArray[2], #())\n\n        returnArray[1] = for item in namePartsOrder[1] collect \"\"\n        returnArray[3] = for item in namePartsOrder[3] collect \"\"\n\n        for i = 1 to namePartsOrder[1].count do (\n            case namePartsOrder[1][i] of (\n                #npBase:(\n                    returnArray[1][i] = get_base_type_part_char beforeRealNameArray namePartsOrder[1] namePartsOrder[1][i]\n                )\n                #npType:(\n                    returnArray[1][i] = get_base_type_part_char beforeRealNameArray namePartsOrder[1] namePartsOrder[1][i]\n                )\n                #npIndex:(\n                    returnArray[1][i] = get_index_side_frontBack_part_char beforeRealNameArray namePartsOrder[1] namePartsOrder[1][i]\n                )\n                #npSide:(\n                    returnArray[1][i] = get_index_side_frontBack_part_char beforeRealNameArray namePartsOrder[1] namePartsOrder[1][i]\n                )\n                #npFrontBack:(\n                    returnArray[1][i] = get_index_side_frontBack_part_char beforeRealNameArray namePartsOrder[1] namePartsOrder[1][i]\n                )\n            )\n        )\n        for i = 1 to namePartsOrder[3].count do (\n            case namePartsOrder[3][i] of (\n                #npBase:(\n                    returnArray[3][i] = get_base_type_part_char afterRealNameArray namePartsOrder[3] namePartsOrder[3][i]\n                )\n                #npType:(\n                    returnArray[3][i] = get_base_type_part_char afterRealNameArray namePartsOrder[3] namePartsOrder[3][i]\n                )\n                #npIndex:(\n                    returnArray[3][i] = get_index_side_frontBack_part_char afterRealNameArray namePartsOrder[3] namePartsOrder[3][i]\n                )\n                #npSide:(\n                    returnArray[3][i] = get_index_side_frontBack_part_char afterRealNameArray namePartsOrder[3] namePartsOrder[3][i]\n                )\n                #npFrontBack:(\n                    returnArray[3][i] = get_index_side_frontBack_part_char afterRealNameArray namePartsOrder[3] namePartsOrder[3][i]\n                )\n            )\n        )\n\n        returnArray\n    ),\n\n    fn get_side inStr = (\n        local sidePos = get_pos_from_refined_nameArray #npSide\n        local nameArray = (split_into_refined_nameArray inStr)[sidePos]\n        local namePartsOrderArray = (split_nameParts_to_refined_nameArray())[sidePos]\n        local sideStr = get_index_side_frontBack_part_char nameArray namePartsOrderArray #npSide\n\n        sideStr\n    ),\n\n    fn get_frontBack inStr = (\n        local frontBackPos = get_pos_from_refined_nameArray #npFrontBack\n        local nameArray = (split_into_refined_nameArray inStr)[frontBackPos]\n        local namePartsOrderArray = (split_nameParts_to_refined_nameArray())[frontBackPos]\n        local frontBackStr = get_index_side_frontBack_part_char nameArray namePartsOrderArray #npFrontBack\n\n        frontBackStr\n    ),\n\n    fn get_index inStr = (\n        local indexPos = get_pos_from_refined_nameArray #npIndex\n        local nameArray = (split_into_refined_nameArray inStr)[indexPos]\n        local namePartsOrderArray = (split_nameParts_to_refined_nameArray())[indexPos]\n        local indexStr = get_index_side_frontBack_part_char nameArray namePartsOrderArray #npIndex\n\n        indexStr\n    ),\n\n    fn is_nub inStr = (\n        local returnVal = false\n        if (get_index inStr) == __nubStr then returnVal = true\n        returnVal\n    ),\n\n    fn get_index_as_digit inStr = (\n        if (is_nub inStr) then return -1\n\n        indexStr = get_index inStr\n        if indexStr != \"\" then (\n            index = execute indexStr\n            return index\n        )\n        else return false\n    ),\n\n    fn get_base inStr = (\n        local basePos = get_pos_from_refined_nameArray #npBase\n        local nameArray = (split_into_refined_nameArray inStr)[basePos]\n        local namePartsOrderArray = (split_nameParts_to_refined_nameArray())[basePos]\n        local baseStr = get_base_type_part_char nameArray namePartsOrderArray #npBase\n\n        baseStr\n    ),\n\n    fn get_type inStr = (\n        local typePos = get_pos_from_refined_nameArray #npType\n        local nameArray = (split_into_refined_nameArray inStr)[typePos]\n        local namePartsOrderArray = (split_nameParts_to_refined_nameArray())[typePos]\n        local typeStr = get_base_type_part_char nameArray namePartsOrderArray #npType\n\n        typeStr\n    ),\n\n    fn get_string inStr = (\n        local returnStr = \"\"\n        local filChar = get_filteringChar inStr\n        local nameArray = split_into_refined_nameArray inStr\n        local indexRemovedNameArray = deepCopy nameArray\n        local indexStr = get_index inStr\n        local indexOrder = 0\n        local returnNameArray = #()\n\n        if indexStr != \"\" then indexOrder = findItem indexRemovedNameArray indexStr\n        if indexOrder > 0 then (\n            returnNameArray = deleteItem indexRemovedNameArray indexOrder\n        )\n        returnStr = combine_nameArray returnNameArray filChar\n        returnStr\n    ),\n\n    fn set_index_as_nub inStr = (\n        local returnName = \"\"\n        local filChar = get_filteringChar inStr\n        local nameArray = split_into_refined_nameArray inStr\n        local indexStr = get_index inStr\n        if indexStr != \"\" then (\n            local indexOrder = findItem nameArray indexStr\n            if indexOrder != 0 then nameArray[indexOrder] = __nubStr\n        )\n        else insertItem __nubStr nameArray (get_index_part_index())\n        returnName = combine_nameArray nameArray filChar\n        returnName\n    ),\n\n    fn get_side_char inStr = (\n        local returnChar = \"\"\n        local nameArray = split_into_refined_nameArray inStr\n        local index = get_index inStr\n        local indexPos = findItem nameArray index\n\n        local indexBeforeNameArray = #()\n        local indexAfterNameArray = #()\n\n        local indexBeforeSideCharArray = #()\n        local indexAfterSideCharArray = #()\n\n        if indexPos > 0 then (\n            for i = 1 to (indexPos - 1) do append indexBeforeNameArray nameArray[i]\n            for i = (indexPos + 1) to nameArray.count do append indexAfterNameArray nameArray[i]\n            for item in indexBeforeNameArray do (\n                local foundSideIndex = findItem __sideStrArray (toUpper item)\n                if foundSideIndex > 0 then append indexBeforeSideCharArray item\n            )\n            for item in indexAfterNameArray do (\n                local foundSideIndex = findItem __sideStrArray (toUpper item)\n                if foundSideIndex > 0 then append indexAfterSideCharArray item\n            )\n        )\n        else (\n            for i = 1 to nameArray.count do append indexBeforeNameArray nameArray[i]\n            for item in indexBeforeNameArray do (\n                local foundSideIndex = findItem __sideStrArray (toUpper item)\n                if foundSideIndex > 0 then append indexBeforeSideCharArray item\n            )\n            indexAfterSideCharArray = deepCopy indexBeforeSideCharArray\n        )\n\n        if indexBeforeSideCharArray.count > 0 or indexAfterSideCharArray.count > 0 then (\n            if (get_side_part_index()) < (get_index_part_index()) then (\n                if indexBeforeSideCharArray.count > 0 then returnChar = indexBeforeSideCharArray[1]\n            )\n            else (\n                if indexAfterSideCharArray.count > 0 then returnChar = indexAfterSideCharArray[1]\n            )\n        )\n\n        returnChar\n    ),\n\n    fn get_front_back_char inStr = (\n        local returnChar = \"\"\n        local nameArray = split_into_refined_nameArray inStr\n        local index = get_index inStr\n        local indexPos = findItem nameArray index\n\n        local indexBeforeNameArray = #()\n        local indexAfterNameArray = #()\n\n        local indexBeforeFrontBackCharArray = #()\n        local indexAfterFrontBackCharArray = #()\n\n        if indexPos > 0 then (\n            for i = 1 to (indexPos - 1) do append indexBeforeNameArray nameArray[i]\n            for i = (indexPos + 1) to nameArray.count do append indexAfterNameArray nameArray[i]\n            for item in indexBeforeNameArray do (\n                local foundFrontBackIndex = findItem __frontBackStrArray (toUpper item)\n                if foundFrontBackIndex > 0 then append indexBeforeFrontBackCharArray item\n            )\n            for item in indexAfterNameArray do (\n                local foundFrontBackIndex = findItem __frontBackStrArray (toUpper item)\n                if foundFrontBackIndex > 0 then append indexAfterFrontBackCharArray item\n            )\n        )\n        else (\n            for i = 1 to nameArray.count do append indexBeforeNameArray nameArray[i]\n            for item in indexBeforeNameArray do (\n                local foundFrontBackIndex = findItem __frontBackStrArray (toUpper item)\n                if foundFrontBackIndex > 0 then append indexBeforeFrontBackCharArray item\n            )\n            indexAfterFrontBackCharArray = deepCopy indexBeforeFrontBackCharArray\n        )\n\n        if indexBeforeFrontBackCharArray.count > 0 or indexAfterFrontBackCharArray.count > 0 then (\n            if (get_front_back_part_index()) < (get_index_part_index()) then (\n                if indexBeforeFrontBackCharArray.count > 0 then returnChar = indexBeforeFrontBackCharArray[1]\n            )\n            else (\n                if indexAfterFrontBackCharArray.count > 0 then returnChar = indexAfterFrontBackCharArray[1]\n            )\n        )\n\n        returnChar\n    ),\n\n    fn is_left inStr = (\n        local sideChar = toUpper (get_side_char inStr)\n        if sideChar != \"\" and sideChar == get_leftStr() then return true\n        return false\n    ),\n\n    fn is_right inStr = (\n        local sideChar = toUpper (get_side_char inStr)\n        if sideChar != \"\" and sideChar == get_rightStr() then return true\n        return false\n    ),\n\n    fn is_front inStr = (\n        local sideChar = toUpper (get_front_back_char inStr)\n        if sideChar != \"\" and sideChar == get_frontStr() then return true\n        return false\n    ),\n\n    fn is_back inStr = (\n        local sideChar = toUpper (get_front_back_char inStr)\n        if sideChar != \"\" and sideChar == get_backStr() then return true\n        return false\n    ),\n\n    fn has_side inStr = (\n        if (is_left inStr) then return true\n        if (is_right inStr) then return true\n\n        return false\n    ),\n\n    fn has_front_back inStr = (\n        if (is_front inStr) then return true\n        if (is_back inStr) then return true\n    ),\n\n    fn get_nonRealName inStr = (\n        local filChar = get_filteringChar inStr\n        local baseIndex = get_base_part_index()\n        local typeIndex = get_type_part_index()\n        local sideIndex = get_side_part_index()\n        local frontBackIndex = get_front_back_part_index()\n\n        local base = get_base inStr\n        local type = get_type inStr\n        local side = get_side_char inStr\n        local frontBack = get_front_back_char inStr\n\n        local partsIndexArray = #(baseIndex, typeIndex, sideIndex, frontBackIndex)\n        local partsArray = #(base, type, side, frontBack)\n        local nonRealNameArray = #()\n        for i = 1 to __namePartsOrder.count do append nonRealNameArray \"\"\n        for i = 1 to partsIndexArray.count do (\n            if partsIndexArray[i] != 0 then nonRealNameArray[partsIndexArray[i]] = partsArray[i]\n        )\n\n        local returnStr = \"\"\n        returnStr = combine_nameArray nonRealNameArray filChar\n\n        returnStr\n    ),\n\n    fn combine inBase inType inSide inRealName inIndex inFilChar = (\n        local returnStr = \"\"\n        local baseIndex = get_base_part_index()\n        local typeIndex = get_type_part_index()\n        local sideIndex = get_side_part_index()\n        local frontBackIndex = get_front_back_part_index()\n        local realNameIndex = get_realName_part_index()\n        local indexIndex = get_index_part_index()\n\n        local base = inBase\n        local type = inType\n        local side = inSide\n        local frontBack = \"\"\n        local realName = inRealName\n        local index = inIndex\n\n        local partsIndexArray = #(baseIndex, typeIndex, sideIndex, frontBackIndex, realNameIndex, indexIndex)\n        local partsArray = #(base, type, side, frontBack, realName, index)\n        local combinedNameArray = #()\n\n        for i = 1 to __namePartsOrder.count do append combinedNameArray \"\"\n        for i = 1 to partsIndexArray.count do (\n            if partsIndexArray[i] != 0 then combinedNameArray[partsIndexArray[i]] = partsArray[i]\n        )\n\n        returnStr = combine_nameArray combinedNameArray inFilChar\n\n        returnStr\n    ),\n\n    fn add_prefix_to_realName inStr inPrefix = (\n        local filChar = get_filteringChar inStr\n        local base = get_base inStr\n        local type = get_type inStr\n        local side = get_side inStr\n        local realName = get_realName inStr\n        local index = get_index inStr\n\n        return (combine base type side (inPreFix + realName) index filChar)\n    ),\n\n    fn add_sufix_to_realName inStr inSufix = (\n        local filChar = get_filteringChar inStr\n        local base = get_base inStr\n        local type = get_type inStr\n        local side = get_side inStr\n        local realName = get_realName inStr\n        local index = get_index inStr\n\n        return (combine base type side (realName + inSufix) index filChar)\n    ),\n\n    fn set_index_padding_num inStr inPaddingNum:3 = (\n        local indexStr = get_index inStr\n        local formatStr = \"0\" + (inPaddingNum as String) + \"d\"\n        local index = get_index_as_digit inStr\n\n        if indexStr != \"\" then (\n            if index > -1 then indexStr = formattedPrint index format:formatStr\n            if index == -1 then indexStr = __nubStr\n        )\n\n        local filChar = get_filteringChar inStr\n        local base = get_base inStr\n        local type = get_type inStr\n        local side = get_side inStr\n        local realName = get_realName inStr\n\n        return (combine base type side realName indexStr filChar)\n    ),\n\n    fn get_index_padding_num inStr = (\n        local index = get_index inStr\n        if index != __nubStr then (\n            if index.count > 0 then return index.count\n        )\n\n        return 1\n    ),\n\n    fn increase_index inStr inAmount = (\n        local newName = \"\"\n        if (is_nub inStr) == false then (\n            local filChar = get_filteringChar inStr\n            local base = get_base inStr\n            local type = get_type inStr\n            local side = get_side inStr\n            local realName = get_realName inStr\n            local index = get_index inStr\n            local indexNum = get_index_as_digit inStr\n            local indexPaddingNum = get_index_padding_num inStr\n\n            if indexNum == false then indexNum = 0\n            indexNum = indexNum + inAmount\n            if indexNum == -1 then indexNum = __nubStr\n            newName = combine base type side realName (indexNum as string) filChar\n            newName = set_index_padding_num newName inPaddingNum:indexPaddingNum\n        )\n        else newName = inStr\n\n        return newName\n    ),\n\n    fn replace_filteringChar inStr inNewFilChar = (\n        local base = get_base inStr\n        local type = get_type inStr\n        local side = get_side inStr\n        local realName = get_realName inStr\n        local index = get_index inStr\n\n        return (combine base type side realName index inNewFilChar)\n    ),\n\n    fn replace_base inStr inNewBase = (\n        local filChar = get_filteringChar inStr\n        local type = get_type inStr\n        local side = get_side inStr\n        local realName = get_realName inStr\n        local index = get_index inStr\n\n        return (combine inNewBase type side realName index filChar)\n    ),\n\n    fn replace_type inStr inNewType = (\n        local filChar = get_filteringChar inStr\n        local base = get_base inStr\n        local side = get_side inStr\n        local realName = get_realName inStr\n        local index = get_index inStr\n\n        return (combine base inNewType side realName index filChar)\n    ),\n\n    fn replace_side inStr inNewSide = (\n        local filChar = get_filteringChar inStr\n        local base = get_base inStr\n        local type = get_type inStr\n        local realName = get_realName inStr\n        local index = get_index inStr\n\n        return (combine base type inNewSide realName index filChar)\n    ),\n\n    fn replace_index inStr inNewIndex keepPadding:true = (\n        local filChar = get_filteringChar inStr\n        local base = get_base inStr\n        local type = get_type inStr\n        local side = get_side inStr\n        local realName = get_realName inStr\n\n        local returnName = combine base type side realName inNewIndex filChar\n        if keepPadding then (\n            local indexPaddingNum = get_index_padding_num inStr\n            returnName = set_index_padding_num returnName inPaddingNum:indexPaddingNum\n        )\n\n        return returnName\n    ),\n\n    fn replace_realName inStr inNewRealName = (\n        local filChar = get_filteringChar inStr\n        local base = get_base inStr\n        local type = get_type inStr\n        local side = get_side inStr\n        local index = get_index inStr\n\n        return (combine base type side inNewRealName index filChar)\n    ),\n\n    fn remove_type inStr = (\n        local filChar = get_filteringChar inStr\n        local base = get_base inStr\n        local side = get_side inStr\n        local realName = get_realName inStr\n        local index = get_index inStr\n\n        return (combine base \"\" side realName index filChar)\n    ),\n\n    fn remove_side inStr = (\n        local filChar = get_filteringChar inStr\n        local base = get_base inStr\n        local type = get_type inStr\n        local realName = get_realName inStr\n        local index = get_index inStr\n\n        return (combine base type \"\" realName index filChar)\n    ),\n\n    fn remove_index inStr = (\n        local returnName = replace_index inStr \"\"\n        returnName\n    ),\n\n    fn remove_base inStr = (\n        local returnName = replace_base inStr \"\"\n        returnName\n    ),\n\n    fn gen_mirroring_name inStr = (\n        local returnName = inStr\n        if (is_left inStr) then returnName = replace_side inStr \"R\"\n        if (is_right inStr) then returnName = replace_side inStr \"L\"\n        if (is_front inStr) then returnName = replace_side inStr \"B\"\n        if (is_back inStr) then returnName = replace_side inStr \"F\"\n\n        if returnName == inStr then returnName = increase_index inStr 1\n\n        return returnName\n    ),\n\n    fn sort_by_index inNameArray = (\n        if inNameArray.count > 0 then (\n            struct indexSorting (oriIndex, newIndex)\n\n            local sortedNameArray = #()\n            local structArray = #()\n\n            for i = 1 to inNameArray.count do (\n                local tempIndex = get_index_as_digit inNameArray[i]\n                if tempIndex == false then (\n                    structArray[i] indexSorting i 0\n                )\n                else structArray[i] = indexSorting i tempIndex\n            )\n\n            qsort structArray (fn myLevel v1 v2 = (v1.newIndex - v2.newIndex))\n\n            for i = 1 to inNameArray.count do append sortedNameArray inNameArray[structArray[i].oriIndex]\n\n            return sortedNameArray\n        )\n        return #()\n    ),\n\n    fn gen_uniqueName inStr indexPaddingNum:3 = (\n        local oriName = get_string inStr\n        local filChar = get_filteringChar inStr\n        local resultName = uniqueName (oriName + filChar)\n        local indexStr = (get_index_as_digit resultName) as String\n        resultName = replace_index resultName indexStr\n        resultName = set_index_padding_num resultName inPaddingNum:indexPaddingNum\n\n        resultName\n    )\n)\n",
			"file": "src/name.ms",
			"file_size": 46650,
			"file_write_time": 131907067837621561,
			"settings":
			{
				"buffer_size": 45413,
				"line_ending": "Windows",
				"scratch": true
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 104.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"instp",
				"Package Control: Install Package"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"syn max",
				"Set Syntax: MaxScript"
			],
			[
				"pac",
				"Package Control: List Packages"
			],
			[
				"synhsl",
				"Set Syntax: High Level SL"
			],
			[
				"synhls",
				"Set Syntax: High Level SL"
			],
			[
				"synma",
				"Set Syntax: MaxScript"
			],
			[
				"packagecoin",
				"Package Control: Install Package"
			],
			[
				"syntcg",
				"Set Syntax: Cg"
			],
			[
				"synhlsl",
				"Set Syntax: High Level SL"
			],
			[
				"synthls",
				"Set Syntax: High Level SL"
			],
			[
				"synmax",
				"Set Syntax: MaxScript"
			],
			[
				"syncg",
				"Set Syntax: Cg"
			],
			[
				"synhl",
				"Set Syntax: High Level SL"
			],
			[
				"syn hls",
				"Set Syntax: High Level SL"
			],
			[
				"synta html",
				"Set Syntax: HTML"
			],
			[
				"syn html",
				"Set Syntax: HTML"
			],
			[
				"synta ht",
				"Set Syntax: HTML"
			],
			[
				"syn hl",
				"Set Syntax: High Level SL"
			],
			[
				"packli",
				"Package Control: List Packages"
			],
			[
				"packagi",
				"Package Control: Install Package"
			],
			[
				"pacin",
				"Package Control: Install Package"
			],
			[
				"syntahl",
				"Set Syntax: High Level SL"
			],
			[
				"syntacg",
				"Set Syntax: Cg"
			],
			[
				"packin",
				"Package Control: Install Package"
			],
			[
				"packain",
				"Package Control: Install Package"
			],
			[
				"packa",
				"Package Control: List Packages"
			],
			[
				"packagein",
				"Package Control: Install Package"
			]
		],
		"width": 400.0
	},
	"console":
	{
		"height": 167.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/D/Dropbox/Programing/JalMaxScript/JalTools/Lib/src"
	],
	"file_history":
	[
		"/D/Dropbox/Programing/JalMaxScript/JalTools/Lib/src/name.ms",
		"/D/Dropbox/GameProject/SuperAverageGirl/Config/DefaultEngine.ini",
		"/D/Dropbox/GameProject/SuperAverageGirl/Config/DefaultDeviceProfiles.ini",
		"/D/Dropbox/Download/vertex_normals_stitcher_v.1.2/Vertex_Normals_Stitcher.mcr",
		"/D/Dropbox/Download/noorsnormalthief (1).ms",
		"/D/Dropbox/Download/noorsnormalthief.ms",
		"/D/Dropbox/Programing/JalMaxScript/JalTools/HairTool/src/test.ms",
		"/D/Dropbox/Programing/MaxScript/B6MaxTools/B6HairTool/B6PigTailHairTool.ms",
		"/D/Dropbox/Programing/JalTool/JalLib/src/align.ms",
		"/C/Users/jalnaga/AppData/Local/Autodesk/3dsMax/2019 - 64bit/ENU/usermacros/jalTools-jal_align_pos_only.mcr",
		"/C/Users/jalnaga/AppData/Local/Autodesk/3dsMax/2019 - 64bit/ENU/usermacros/jalTools-jal_align_to_last.mcr",
		"/C/Users/jalnaga/AppData/Local/Autodesk/3dsMax/2019 - 64bit/ENU/usermacros/jalScriptLauncher/jal_align_macro.mcr",
		"/D/Dropbox/Programing/JalTool/JalLib/src/jalLibHeader.ms",
		"/C/Users/jalnaga/AppData/Local/Autodesk/3dsMax/2019 - 64bit/ENU/usermacros/jalScriptLauncher/ini/scriptPath.ini",
		"/C/Users/jalnaga/AppData/Local/Autodesk/3dsMax/2019 - 64bit/ENU/scripts/startup/jalScriptLauncher/jalLoadLib.ms",
		"/C/Program Files/Autodesk/3ds Max 2019/MacroScripts/Macro_SkinTools.mcr",
		"/D/JalTool/JalLib/JalLib.ms",
		"/D/Dropbox/Programing/JalTool/JalScriptInstaller/src/jalScriptLauncher/macroscripts/jal_align_macro.mcr",
		"/D/Dropbox/Programing/JalTool/JalScriptInstaller/src/jalInstall.ms",
		"/D/JalTool/JalMacro/jal_align_macro.ms",
		"/D/Dropbox/Programing/JalTool/JalScriptInstaller/src/mzp.run",
		"/D/Dropbox/Programing/JalTool/JalScriptInstaller/src/jalScriptLauncher/ini/scriptPath.ini",
		"/D/Dropbox/Programing/JalTool/JalScriptInstaller/src/jalScriptLauncher/macroscripts/jalScriptLauncher.mcr",
		"/D/Download/JalScriptInstaller/src/test.ms",
		"/D/Download/JalScriptInstaller/src/installINI.ini",
		"/D/Download/JalScriptInstaller/src/jalScriptLauncher/macroscripts/jal_align_macro.mcr",
		"/C/Users/dongseokKim/AppData/Local/Autodesk/3dsMax/2019 - 64bit/ENU/usermacros/jalScriptLauncher/ini/scriptPath.ini",
		"/C/Users/dongseokKim/AppData/Local/Autodesk/3dsMax/2019 - 64bit/ENU/usermacros/jalScriptLauncher/jalScriptLauncher.mcr",
		"/C/Users/dongseokKim/AppData/Local/Autodesk/3dsMax/2019 - 64bit/ENU/usermacros/jalScriptLauncher/jal_align_macro.mcr",
		"/C/Users/dongseokKim/AppData/Local/Autodesk/3dsMax/2019 - 64bit/ENU/scripts/startup/jalScriptLauncher/jalLoadLib.ms",
		"/D/Download/JalScriptInstaller/src/jalScriptLauncher/startupScript/jalLoadLib.ms",
		"/D/JalTool/JalTools/HandyTool/HandyTool.ms",
		"/D/Download/JalScriptInstaller/src/jalScriptLauncher/macroscripts/jal_align_macro.ms",
		"/D/Download/JalScriptInstaller/src/jalScriptLauncher/macroscripts/jalScriptLauncher.mcr",
		"/D/Dropbox/Download/JalScriptInstaller/src/jalScriptLauncher/externalScript/JalTools/NameTool/NameTool.ms",
		"/D/Dropbox/Download/JalScriptInstaller/src/jalScriptLauncher/externalScript/JalTools/HandyTool/HandyTool.ms",
		"/D/Dropbox/Download/JalScriptInstaller/src/jalScriptLauncher/macroscripts/jalScriptLauncher.mcr",
		"/D/Dropbox/Download/JalScriptInstaller/src/installINI.ini",
		"/D/Dropbox/Download/JalScriptInstaller/src/jalScriptLauncher/startupScript/jalLoadLib.ms",
		"/D/Dropbox/Download/JalScriptInstaller/src/jalScriptLauncher/ini/scriptPath.ini",
		"/D/JalTool/JalMacro/jal_helper_macro.ms",
		"/D/JalTool/JalMacro/jal_constraint_macro.ms",
		"/D/Dropbox/Download/JalScriptInstaller/src/mzp.run",
		"/D/Dropbox/Download/JalScriptInstaller/src/ini/test.text",
		"/D/Dropbox/Download/JalScriptInstaller/src/ini/scriptPath.ini",
		"/C/Users/jalnaga/AppData/Roaming/Sublime Text 3/Packages/User/Anaconda.sublime-settings",
		"/D/JalDev/MaxScript/JalScript/JalScriptInstaller/src/startupScript/jalLoadLib.ms",
		"/D/JalDev/MaxScript/JalScript/JalScriptInstaller/src/macroscripts/jalScriptLauncher.mcr",
		"/D/JalDev/MaxScript/JalScriptInstaller/src/preventUnwantedScriptRun.ms",
		"/D/JalDev/MaxScript/JalScriptInstaller/src/vrdematcleanbeta.mse",
		"/D/JalDev/MaxScript/JalScriptInstaller/src/macroscripts/jalScriptLauncher.mcr",
		"/D/JalDev/MaxScript/JalScriptInstaller/src/jalToolLauncher_install.ms",
		"//172.20.80.191/art_shared_new/RnD_share/JalTools/JalScript/JalScript.ms",
		"/C/Users/dongseokKim/AppData/Local/Autodesk/3dsMax/2017 - 64bit/ENU/usermacros/jalTools-jalScriptLauncher.mcr",
		"/D/JalDev/MaxScript/JalScriptInstaller/src/templateGenerator.ms",
		"/D/JalDev/MaxScript/JalScriptInstaller/src/startupScript/jalLoadLib.ms",
		"//172.20.80.191/art_shared_new/R&D팀/김동석/JalTools/HandyTool/HandyTool.ms",
		"//172.20.80.191/art_shared_new/R&D팀/김동석/JalTools/JalScript/JalScript.ms",
		"/D/JalDev/MaxScript/JalScriptInstaller/src/mzp.run",
		"/D/JalDev/MaxScript/ScriptInstaller/src/mzp.run",
		"/D/JalDev/MaxScript/ScriptInstaller/src/templateGenerator.ms",
		"/E/09.작업 가이드/html/몬스터 가죽 재질 사용 가이드.html",
		"/E/09.작업 가이드/html/가죽 재질 사용 가이드.html",
		"/E/09.작업 가이드/html/털 재질 사용 가이드.html",
		"/E/Dropbox/Programing/MaxScript/B6MaxTools/B6Lib/B6_GlobalLib.ms",
		"/E/Dropbox/Programing/MaxScript/B6MaxTools/B6BipTool/B6BipTool.ms",
		"/E/Dropbox/Programing/MaxScript/B6MaxTools/B6MapBakingTool/B6MapBakingTool.ms",
		"/E/Dropbox/Programing/MaxScript/ScriptInstaller/src/mzp.run",
		"/E/Dropbox/Programing/MaxScript/ScriptInstaller/src/ScriptInstaller/macroscripts/jalCharacterExportToolMacro.mcr",
		"/C/Program Files/Autodesk/3ds Max 2015/stdplugs/stdscripts/NET_ListViewWrapper.ms",
		"/C/Users/dongseok-kim/Desktop/thumnailviewtest.ms",
		"/E/Dropbox/Programing/MaxScript/ScriptInstaller/src/templateGenerator.ms",
		"/C/Users/dongseok-kim/AppData/Roaming/Sublime Text 2/Packages/User/Preferences.sublime-settings",
		"/E/Dropbox/Programing/MaxScript/ScriptInstaller/src/macroscripts/jalCharacterExportToolMacro.mcr",
		"/C/Users/dongseok-kim/AppData/Roaming/Sublime Text 2/Packages/User/MaxScript.sublime-settings",
		"/E/Dropbox/Programing/MaxScript/ScriptInstaller/src/jalToolLauncher_install.ms",
		"/e/dorpbox/programing/maxscirpt/listviewTest/listviewTest.ms",
		"/E/09.작업 가이드/html/레이어드 몬스터 매테리얼 사용 가이드.html",
		"//vfs01/Victoria_Art/09.작업 가이드/index.md",
		"//vfs01/Victoria_Art/09.작업 가이드/html/AO맵 가이드.html",
		"//vfs01/Victoria_Art/09.작업 가이드/md/식생 작업 가이드.md",
		"//vfs01/Victoria_Art/09.작업 가이드/max_script/SLscripts-indexshow.mcr",
		"/E/Dropbox/Programing/MaxScript/HairTool/Hairtool.sublime-project",
		"/E/Dropbox/Programing/MaxScript/HairTool/Hairtool.sublime-workspace",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/progress.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/ui_boneByHandRollout.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/ui_boneRollout.ms",
		"/E/Dropbox/Programing/MaxScript/Lib/layer.ms",
		"/C/Users/dongseok-kim/AppData/Roaming/Sublime Text 2/Packages/User/ConvertToUTF8.sublime-settings",
		"/C/Users/dongseok-kim/AppData/Roaming/Sublime Text 2/Packages/ConvertToUTF8/ConvertToUTF8.sublime-settings",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/material.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/ui_export.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/ui_tipMovementRollout.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/ui_vertexPaintRollout.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/ui_clumpingRollout.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/ui_boneRename.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/ui_prepareRollout.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/ui_progressRollout.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/detachElement.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/hairPlane.ms",
		"/E/Downloads/SlideTools-SlideNormalThief.mcr",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/ui_mainRollout.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/test.ms",
		"/E/Dropbox/Custom Data/Sublime Text Settings/Preferences.sublime-settings",
		"/E/Dropbox/Custom Data/Sublime Text Settings/Python.sublime-settings",
		"/E/Dropbox/Programing/PyPixiv/test.py",
		"/C/Users/dongseok-kim/AppData/Roaming/Sublime Text 2/Packages/User/Default (Windows).sublime-keymap",
		"/C/Users/dongseok-kim/AppData/Roaming/Sublime Text 2/Packages/Default/Default (Windows).sublime-keymap",
		"/C/Users/dongseok-kim/AppData/Roaming/Sublime Text 2/Packages/User/Python.sublime-settings",
		"/C/Users/dongseok-kim/Desktop/vertexPaintTest.ms",
		"/E/Downloads/Invert_VC_v2.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/vertMatchWithMapVert.ms",
		"/E/Downloads/Invert_VC.ms",
		"/C/Program Files/Autodesk/3ds Max 2015/MacroScripts/Macro_VertexPaint.mcr",
		"/E/Downloads/skinslicer.ms",
		"/E/Downloads/skin_slice_skin_v09_dev.ms",
		"/C/Users/dongseok-kim/Desktop/MacroScripts/AwStart.mcr",
		"/C/Users/dongseok-kim/Desktop/listViewTest.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/hair.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/final/hairtool.ms",
		"/E/Dropbox/Programing/MaxScript/HairTool/src/fbx.ms",
		"/E/Dropbox/Programing/MaxScript/Lib/bip.ms",
		"/E/Dropbox/Programing/MaxScript/Lib/boneCreate.ms",
		"/E/Dropbox/Programing/MaxScript/Lib/detachElement.ms",
		"/E/Dropbox/Programing/MaxScript/Lib/fbx.ms",
		"/E/Dropbox/Programing/MaxScript/Lib/export.ms",
		"/E/Dropbox/Programing/MaxScript/Lib/material.ms",
		"/E/Dropbox/Programing/MaxScript/Lib/progress.ms"
	],
	"find":
	{
		"height": 49.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"get_index",
			"get_frontBack",
			"get_side",
			"get_index",
			"get_frontBack",
			"get_side",
			"get_base",
			"get_type",
			"baseStr",
			"basePos",
			"npIndex",
			"indexStr",
			"indexPos",
			"k -= 1",
			"i += 1",
			"k -= 1",
			"is_front_back_char",
			"npIndex",
			"indexStr",
			"indexPos",
			"get_side",
			"swcondPartIndex",
			"firstPartIndex",
			"targetIndexInNameArray",
			"firstPartIndex",
			"get_side",
			"namePartsOrderArray",
			"inNamePartsOrder",
			"namePartsOrder[3]",
			"namePartsOrder[1]",
			"baseIndex",
			"typeIndex",
			"baseIndex",
			"npSide",
			"sideStr",
			"sidePos",
			"npIndex",
			"indexStr",
			"indexPos",
			"refine_empty_in_nameArray",
			"split_by_upper_case",
			"split_by_filteringChar",
			"split_name",
			"targetIndex",
			"inNamePartsArray",
			"indexIndex",
			"indexArray",
			"indexPos",
			"indexStr",
			"get_pos_from_refined_nameArray",
			"indexStr",
			"indexArray",
			"get_index_part_index",
			"indexIndex",
			"indexPos",
			"indexStr",
			"),\n",
			"get_pos_from_refined_nameArray",
			"typePos",
			"basePos",
			"beforeRealNameArray",
			"returnArray[1]",
			"namePartsOrder[1]",
			"get_base_type_part_char",
			"typPos",
			"targetPosInNameArray",
			"returnArray",
			"namePartsOrder",
			"beforeRealNameArray",
			"local",
			"targetIndex",
			"get_index_side_frontBack_part_char",
			"beforeRealNameArray",
			"testArray",
			"inNameArray",
			"nameArray",
			"targetChar",
			"returnArray[1]",
			"get_part_char",
			"indexStr",
			"indexIndex",
			"indexArray",
			"nameArray",
			"inNameArray",
			"is_front_back_char",
			"frontBackIndex",
			"sideIndex",
			"is_front_back_char",
			"sideIndex",
			"nameArray",
			"returnArray[1]",
			"namePartsOrder[1]",
			"returnArray[1]",
			"namePartsOrder[1]",
			"beforeRealNameArray",
			"namePartsOrder",
			"beforeRealNameArray",
			"inNameArray",
			"get_string",
			"nameArray",
			"indexPos",
			"refinedNameArray",
			"get_frontBack_part_index",
			"refine_nameArray",
			"split_into_refined_nameArray",
			"refine_index_in_nameArray",
			"afterRealNameArray",
			"tempAfterRealNameArray",
			"beforeRealNameArray",
			"afterRealNameArray",
			"before",
			"nonRealNameArray",
			"#Index",
			"#RealName",
			"#FrontBack",
			"#Side",
			"#Type",
			"#Base",
			"Base",
			"returnNameArray",
			"emptyRefinedNameArray",
			"jalToolLauncher_install",
			"userMacroDir",
			"tool_path",
			"instalDestDir",
			"tempDir",
			"mcrName",
			"tempDir"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"is_frontBack_char",
			"#npIndex",
			"#npRealName",
			"#npFrontBack",
			"#npSide",
			"#npType",
			"#npBase",
			"externalDestDir",
			"tempInstallDir",
			"",
			"set_weight_group",
			"set_vert_index",
			"set_weight_for_middle_verts",
			"set_weight_for_up_verts",
			"set_weight_for_bottom_verts",
			"set_blend_falloff",
			"set_weight_group_num",
			"get_array_of_verts_to_mapverts",
			"get_array_of_mapverts_to_verts",
			"..",
			"..\\images\\Character\\Substance\\",
			"..\\images\\Character\\LayeredMat\\",
			"..\\images\\Character\\SSSMap\\",
			"..\\images\\Character\\LayeredMat\\BoneMat\\",
			"..\\images\\Character\\LayeredMat\\",
			"..\\images\\Character\\LayeredMat\\FabricMat\\",
			"..\\images\\Character\\FabricMap\\",
			"..\\images\\Character\\LayeredMat\\",
			"..\\images\\Character\\LayeredMat\\leatherMat\\",
			"..\\images\\Character\\LayeredMat\\",
			"..\\images\\Character\\LayeredMat\\MetalMat\\",
			"..\\images\\Character\\LayeredMat\\",
			"../images/Character/Substance/",
			"../images/Character/SSSMap/",
			"../images/Character/Substance/",
			"../images/Character/FabricMap/",
			"../images/Character/Substance/",
			"../images/Character/FabricMap/",
			"../images/Character/SSSMap/",
			"../images/Character/HairMat/",
			"../images/Character/HairTexture/",
			"../images/Character/HairMesh/",
			"../imgaes/Character/HairMesh/"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/_compileTarget.ms",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 763,
						"regions":
						{
						},
						"selection":
						[
							[
								671,
								671
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"markdonw_live_preview_last_run": 1544338914.47,
							"origin_encoding": "ASCII",
							"syntax": "Packages/Send to 3ds Max/MaxScript.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/name.ms",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 45413,
						"regions":
						{
						},
						"selection":
						[
							[
								27829,
								27829
							]
						],
						"settings":
						{
							"force_encoding": "GBK",
							"in_converting": true,
							"markdonw_live_preview_last_run": 1545990398.06,
							"origin_encoding": "GBK",
							"revert_to_scratch": true,
							"syntax": "Packages/Send to 3ds Max/MaxScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3276.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 37.0
	},
	"input":
	{
		"height": 48.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "JalLib.sublime-project",
	"replace":
	{
		"height": 90.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"de",
				"detachElement.ms"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 242.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
